function sim_world_data = update_graphics(sim_world_data)
    
    % expose publicfunctions
    
    sim_world_data.funcs.graphics.update_plot_static = ...
        @(ego,ego_x,ego_y,mov,mov_x,mov_y,onc,onc_x,onc_y) ...
        update_plot_static(...
            ego,ego_x,ego_y,mov,mov_x,mov_y,onc,onc_x,onc_y);
        
    sim_world_data.funcs.graphics.update_plot_dynamic = @(...
            interface,...
            road,road_x,road_y,...
            lane,lane_x,lane_y,...
            road_edge,road_edge_x,road_edge_y,...
            road_area,road_area_x,road_area_y,road_area_z,...
            ego,...
            stand,stand_x,stand_y,...
            mov,mov_x,mov_y,...
            onc,onc_x,onc_y,fov) update_plot_dynamic(...
                interface,...
                road,road_x,road_y,...
                lane,lane_x,lane_y,...
                road_edge,road_edge_x,road_edge_y,...
                road_area,road_area_x,road_area_y,road_area_z,...
                ego,...
                stand,stand_x,stand_y,...
                mov,mov_x,mov_y,...
                onc,onc_x,onc_y,fov);
            
    % *********************** function definitions ***********************

    function update_plot_static(...
            ego,ego_x,ego_y,mov,mov_x,mov_y,onc,onc_x,onc_y)
        % ADAS SimWorld: Update static plots
        
        % update static axes
        set(ego.m.static,'xData',ego_x,'yData',ego_y)
        set(mov.m.static,'xData',mov_x,'yData',mov_y)
        set(onc.m.static,'xData',onc_x,'yData',onc_y)
    end

    function update_plot_dynamic(...
            interface,...
            road,road_x,road_y,...
            lane,lane_x,lane_y,...
            road_edge,road_edge_x,road_edge_y,...
            road_area,road_area_x,road_area_y,road_area_z,...
            ego,...
            stand,stand_x,stand_y,...
            mov,mov_x,mov_y,...
            onc,onc_x,onc_y,fov)
        % ADAS SimWorld: Update dynamic plots
        
        % update dynamic plot data
        set(road.m.dynamic, 'xData',road_y, 'yData',road_x)
        set(lane.m.dynamic, 'xData',lane_y, 'yData',lane_x)
        set(road_edge.m.dynamic, 'xData',road_edge_y, 'yData',road_edge_x)
        
        % update rooad area depending on user-defined tilt angle
        switch road_area.type
            case 'patch'
                terrain_3D = false;
                set(road_area.m.dynamic_patch,'visible','on',...
                    'xData',road_area_y,'yData',road_area_x,...
                    'zData',-0.2*ones(size(road_area_y)))
                set(road_area.m.dynamic_surf_edge,'visible','off')
                set(road_area.m.dynamic_surf,'visible','off')
            case 'surf'
                terrain_3D = true;
                set(road_area.m.dynamic_surf,...
                    'visible','on',...
                    'xData',road_area_y, 'yData',road_area_x,...
                    'cdata',road_area.map,'zdata',road_area_z)
                if road.terrain.a > 0 && ...
                        get(...
                        interface.figures.main.sliders.ax_dynamic_tilt,'value')...
                        < 70
                    d = 1:3:size(road_area_y,1);
                    edge = road_area_z(d,d);
                    edge(road_area.map(d,d) == 0) = nan;
                    set(road_area.m.dynamic_surf_edge,...
                        'visible','on',...
                        'xData',road_area_y(d,d),'yData',road_area_x(d,d),...
                        'cdata',road_area.map(d,d),'zdata',edge)
                else
                    set(road_area.m.dynamic_surf_edge,'visible','off')
                end
                set(road_area.m.dynamic_patch,'visible','off')
        end

        for ii = 1 : stand.n
            if (fov(1,1) <= stand_x(ii)) && (stand_x(ii) <= fov(2,1)) && ...
                    (fov(1,2) <= stand_y(ii)) && (stand_y(ii) <= fov(2,2))
                set(stand.m.dynamic(ii),... % draw standing object cubes
                    'visible','on',...
                    'xData',stand.cube(ii).y(stand.cube(ii).idx),...
                    'yData',stand.cube(ii).x(stand.cube(ii).idx),...
                    'zData',stand.cube(ii).z(stand.cube(ii).idx)+...
                    stand.z(ii)*terrain_3D);
            else
                set(stand.m.dynamic(ii),'visible','off');
            end
        end
        for ii = 1 : mov.n
            if (fov(1,1) <= mov_x(ii)) && (mov_x(ii) <= fov(2,1)) && ...
                    (fov(1,2) <= mov_y(ii)) && (mov_y(ii) <= fov(2,2))
                set(mov.m.dynamic(ii),... % draw moving object cubes
                    'visible','on',...
                    'xData',mov.cube(ii).y(mov.cube(ii).idx),...
                    'yData',mov.cube(ii).x(mov.cube(ii).idx),...
                    'zData',mov.cube(ii).z(mov.cube(ii).idx));
            else
                set(mov.m.dynamic(ii),'visible','off');
            end
        end
        for ii = 1 : onc.n
            if (fov(1,1) <= onc_x(ii)) && (onc_x(ii) <= fov(2,1)) && ...
                    (fov(1,2) <= onc_y(ii)) && (onc_y(ii) <= fov(2,2))
                set(onc.m.dynamic(ii),... % draw oncoming object cubes
                    'visible','on',...
                    'xData',onc.cube(ii).y(onc.cube(ii).idx),...
                    'yData',onc.cube(ii).x(onc.cube(ii).idx),...
                    'zData',onc.cube(ii).z(onc.cube(ii).idx));
            else
                set(onc.m.dynamic(ii),'visible','off');
            end
        end
        
        % update sensor-specific data
        for ii = 1 : ego.sensor.n
            set(ego.sensor.d{ii}.road,...
                'xData',ego.sensor.data(ii).road(:,2),...
                'yData',ego.sensor.data(ii).road(:,1))
            set(ego.sensor.d{ii}.stand,...
                'xData',ego.sensor.data(ii).stand(:,2),...
                'yData',ego.sensor.data(ii).stand(:,1))
            set(ego.sensor.d{ii}.mov,...
                'xData',ego.sensor.data(ii).mov(:,2),...
                'yData',ego.sensor.data(ii).mov(:,1))
            set(ego.sensor.d{ii}.onc,...
                'xData',ego.sensor.data(ii).onc(:,2),...
                'yData',ego.sensor.data(ii).onc(:,1))
        end
    end

end
